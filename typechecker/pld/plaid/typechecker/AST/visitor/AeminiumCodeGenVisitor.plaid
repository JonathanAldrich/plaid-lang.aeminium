package plaid.typechecker.AST.visitor;

import plaid.typechecker.AST.*;
import plaid.typechecker.util.*;

state AeminiumCodeGenVisitor case of CodeGenVisitor {
	method generateCode(methodNode, aemNodeList) {
		val it = aemNodeList.iterator();
		val cc = plaid.compilerjava.CompilerConfiguration.new();
		cc.setPrettyPrint(java.lang.Boolean.TRUE);
		cc.setDebugMode(java.lang.Boolean.FALSE);
		cc.setOutputDir("testOutput/");
		val cg = plaid.compilerjava.util.CodeGen.new(cc);
		val codeGenVisitor = new AeminiumCodeGenVisitor {
			val out = cg;
		};
		
		while { it.hasNext(); } {
			val aemNode = it.next();
			java.lang.System.out.println("Body b" + aemNode.num + " = new Body() {");
			java.lang.System.out.println("	public void execute(Runtime rt, Task parent) {");
			aemNode.astRef.accept(codeGenVisitor);
			java.lang.System.out.println("	}\\n}");
			
			java.lang.System.out.print("Task t" + aemNode.num + " = plaid.runtime.PlaidRuntime.getAeminium().");
			java.lang.System.out.println("createNonBlockingTask(b" + aemNode.num + ", aeminium.runtime.Runtime.NO_HINTS);");
			
			java.lang.System.out.println("Collection<Task> deps" + aemNode.num + " = new ArrayList<Task>();");
			
			val depIt = aemNode.dependencies.iterator();
			while { depIt.hasNext(); } {
				val dep = depIt.next();
				java.lang.System.out.println("deps" + aemNode.num + ".add(t" + dep.to.num + ");");
			};
			java.lang.System.out.println("plaid.runtime.PlaidRuntime.getAeminium().schedule(t" + aemNode.num + ", aeminium.runtime.Runtime.NO_PARENT, deps" + aemNode.num + ");");
			
			java.lang.System.out.println("");
			java.lang.System.out.println("");
		};
	}
	
	override method visitMethodDecl(node) {
		val depVisitor = new DependencyVisitor;
		// We already know it's a method decl
		depVisitor.visitMethodDecl(node);
	}
}